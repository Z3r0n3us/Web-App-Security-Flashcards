<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pentest Flashcards</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        body {
            background-color: #f5f5f7;
            padding: 20px;
            max-width: 100%;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        select {
            padding: 12px;
            padding-right: 40px; /* extra space for the arrow */
            border-radius: 8px;
            border: 1px solid #ccc;
            background-color: white;
            font-size: 16px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><polygon points="0,0 10,0 5,7" fill="%23aaa"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
                
        .flashcard {
            perspective: 1000px;
            height: 300px;
            margin-bottom: 25px;
            cursor: pointer;
        }
        
        .card {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .flipped .card {
            transform: rotateY(180deg);
        }
        
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            border-radius: 12px;
            overflow-y: auto;
        }
        
        .card-front {
            background-color: #ffffff;
            color: #333;
        }
        
        .card-back {
            background-color: #0071e3;
            color: white;
            transform: rotateY(180deg);
        }
        
        .card-content {
            font-size: 20px;
            font-weight: 500;
            line-height: 1.5;
            padding: 10px;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .nav-button {
            background-color: #0071e3;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .nav-button:hover {
            background-color: #0058b0;
        }
        
        .counter {
            text-align: center;
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }
        
        @media (max-width: 480px) {
            .card-content {
                font-size: 18px;
            }
            
            .nav-button {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .flashcard {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pentest Flashcards</h1>
        
        <div class="controls">
            <select id="category-select">
                <option value="owasp">OWASP Top 10 (2021)</option>
                <option value="fundamentals">Web Security Fundamentals</option>
                <option value="tools">Security Testing Tools</option>
                <option value="attacks">Common Attack Techniques</option>
                <option value="bestpractices">Security Best Practices</option>
                <option value="appsec">Application Security</option>
                <option value="cryptography">Cryptography</option>
                <option value="authentication">Authentication & Authorization</option>
                <option value="mobile">Mobile Security</option>
                <option value="ssl-tls">SSL/TLS Security</option>
                <option value="pentesting">Penetration Testing</option>
            </select>
        </div>
        
        <div class="flashcard" id="flashcard">
            <div class="card">
                <div class="card-front">
                    <div class="card-content" id="front-content">
                        Loading question...
                    </div>
                </div>
                <div class="card-back">
                    <div class="card-content" id="back-content">
                        Loading answer...
                    </div>
                </div>
            </div>
        </div>
        
        <div class="navigation">
            <button class="nav-button" id="prev-button">Previous</button>
            <button class="nav-button" id="next-button">Next</button>
        </div>
        
        <div class="counter" id="counter">Card 1 of 10</div>
    </div>

    <script>
        // Flashcard data by category
        const flashcards = {
            owasp: [
                {
                    front: "A01:2021 - What is Broken Access Control?",
                    back: "Broken Access Control occurs when restrictions on authenticated users are not properly enforced. Attackers can exploit these flaws to access unauthorized functionality and/or data, such as accessing other users' accounts, viewing sensitive files, modifying other users' data, or changing access rights."
                },
                {
                    front: "A01:2021 - Give examples of Broken Access Control vulnerabilities.",
                    back: "Examples include: Insecure Direct Object References (IDOR), path traversal attacks, bypassing access control checks, permission elevation, metadata manipulation (e.g., JWT tampering), CORS misconfiguration, and forcing browsing to authenticated pages as an unauthenticated user."
                },
                {
                    front: "A01:2021 - How to prevent Broken Access Control vulnerabilities?",
                    back: "Mitigation: Implement proper access controls: deny by default, enforce record ownership, disable directory listing, log access control failures, rate limit API access, invalidate JWTs on logout, implement stateful session management, use automated testing of access controls, and implement authorization checks at the controller or business logic level rather than the presentation layer."
                },
                {
                    front: "A02:2021 - What are Cryptographic Failures?",
                    back: "Cryptographic Failures are weaknesses related to cryptography (or lack thereof) that often lead to exposure of sensitive data. This includes failures to encrypt data in transit or at rest, using weak or outdated cryptographic algorithms, and improper key management practices."
                },
                {
                    front: "A02:2021 - Give examples of Cryptographic Failures.",
                    back: "Examples include: Transmitting data in clear text (HTTP instead of HTTPS), using weak cryptographic algorithms (MD5, SHA1), hardcoded encryption keys, insufficient entropy, improper certificate validation, using deprecated SSL/TLS versions, and inadequate key rotation."
                },
                {
                    front: "A02:2021 - How to prevent Cryptographic Failures?",
                    back: "Mitigation: Classify and protect sensitive data, don't store unnecessary sensitive data, encrypt all sensitive data at rest using strong algorithms, use proper key management with secure key storage, disable caching for sensitive data, enforce HTTPS with proper certificate validation, use proper password storage with strong adaptive hashing (bcrypt/Argon2), and verify independently the effectiveness of configuration and settings."
                },
                {
                    front: "A03:2021 - What is Injection?",
                    back: "Injection flaws occur when untrusted data is sent to an interpreter as part of a command or query. Common examples include SQL injection, NoSQL injection, OS command injection, and LDAP injection. Attackers' hostile data can trick the interpreter into executing unintended commands or accessing data without authorization."
                },
                {
                    front: "A03:2021 - Give examples of Injection vulnerabilities.",
                    back: "SQL injection, NoSQL injection, OS command injection, LDAP injection, XML injection (XXE), ORM injection, XPath injection, SMTP header injection, template injection, and server-side JavaScript/Ruby/Python injection."
                },
                {
                    front: "A03:2021 - How to prevent Injection vulnerabilities?",
                    back: "Mitigation: Use a safe API that avoids interpreters, implement parameterized queries or prepared statements, use ORM tools with parameter binding, perform positive server-side input validation with allowlisting, escape special characters using the syntax specific to the target interpreter, and use SAST tools and automated testing for injection flaws. For OS commands, use process launching APIs instead of command concatenation."
                },
                {
                    front: "A04:2021 - What is Insecure Design?",
                    back: "Insecure Design refers to risks related to design and architectural flaws, emphasizing the need for secure design patterns, threat modeling, and reference architectures. It's distinct from implementation flaws and represents a broad category of weaknesses that were previously not well-represented in the Top 10."
                },
                {
                    front: "A04:2021 - Give examples of Insecure Design flaws.",
                    back: "Missing authorization checks by design, lack of business limit validation, workflow bypass, insufficient audit trails, implicit trust of client-side validation, lack of rate limiting, missing encryption by design, and privacy control gaps."
                },
                {
                    front: "A04:2021 - How to prevent Insecure Design?",
                    back: "Mitigation: Establish secure development lifecycle with security professionals, use threat modeling for critical flows, integrate security requirements and user stories, reference secure design patterns and architectures, use security integration and unit tests, conduct secure code reviews, limit resource consumption by user, and establish and use a library of secure design patterns. Implement defense in depth at all levels of the application."
                },
                {
                    front: "A05:2021 - What is Security Misconfiguration?",
                    back: "Security Misconfiguration is the most commonly seen issue, often resulting from insecure default configurations, incomplete or ad hoc configurations, open cloud storage, misconfigured HTTP headers, and verbose error messages containing sensitive information."
                },
                {
                    front: "A05:2021 - Give examples of Security Misconfiguration.",
                    back: "Unnecessary features enabled (ports, services, pages), default accounts with unchanged passwords, overly informative error messages, missing security headers, misconfigured SSL/TLS, outdated software, unnecessarily open cloud storage, and unprotected files/directories."
                },
                {
                    front: "A05:2021 - How to prevent Security Misconfiguration?",
                    back: "Mitigation: Implement secure hardening process, platform-specific security configurations, minimal platforms without unnecessary features, automated verification process for configurations, segment application architecture, send security directives to clients (security headers), and automate verification of configurations in all environments. Use a repeatable hardening process that makes it fast and easy to deploy properly locked down environments."
                },
                {
                    front: "A06:2021 - What are Vulnerable and Outdated Components?",
                    back: "Vulnerable and Outdated Components refers to using components (like libraries, frameworks, and other software modules) with known vulnerabilities. This includes using components that are outdated, unsupported, or vulnerable versions that run with the same privileges as the application."
                },
                {
                    front: "A06:2021 - Why are Vulnerable and Outdated Components dangerous?",
                    back: "They can lead to entire application compromise, data loss, or server takeover. If the component runs with elevated privileges, it can affect the entire host system. Many exploits for known vulnerabilities are publicly available and can be easily used by attackers."
                },
                {
                    front: "A06:2021 - How to prevent vulnerabilities from Outdated Components?",
                    back: "Mitigation: Remove unused dependencies, continuously inventory components and their versions, monitor for vulnerabilities using tools like OWASP Dependency-Check, only use official sources, monitor unmaintained libraries, use Software Composition Analysis (SCA) tools in CI/CD, implement virtual patches, and establish a patch management strategy. Subscribe to security bulletins related to your components."
                },
                {
                    front: "A07:2021 - What are Identification and Authentication Failures?",
                    back: "Identification and Authentication Failures occur when functions related to user identity, authentication, or session management are implemented incorrectly. Weaknesses may include permitting automated attacks, brute force attacks, weak credentials, improper session management, and weak or ineffective credential recovery."
                },
                {
                    front: "A07:2021 - Give examples of Identification and Authentication Failures.",
                    back: "Permitting credential stuffing or brute force attacks, allowing weak passwords, using ineffective credential recovery processes, storing passwords in plain text or weakly hashed, missing or ineffective MFA, exposing session identifiers in URLs, and not properly invalidating session IDs."
                },
                {
                    front: "A07:2021 - How to prevent Identification and Authentication Failures?",
                    back: "Mitigation: Implement MFA to prevent automated attacks, credential stuffing, brute force and account recovery attacks; avoid default credentials; implement weak-password checks; align password policy with NIST 800-63b; harden registration and credential recovery processes; use server-side session management with secure cookies; and implement proper session timeouts. Use a server-side, secure built-in session manager that generates new random session IDs with high entropy after login."
                },
                {
                    front: "A08:2021 - What is Software and Data Integrity Failures?",
                    back: "Software and Data Integrity Failures relate to code and infrastructure that does not protect against integrity violations. Examples include relying on plugins from untrusted sources, auto-update functionality without sufficient integrity verification, and CI/CD pipelines without proper security controls."
                },
                {
                    front: "A08:2021 - Give examples of Software and Data Integrity Failures.",
                    back: "Using plugins or libraries from untrusted CDNs or repositories, insecure CI/CD pipeline without proper checks, auto-update mechanisms without digital signatures, unsigned or unverified serialized data, reliance on client-side integrity, and unsigned JWTs."
                },
                {
                    front: "A08:2021 - How to prevent Software and Data Integrity Failures?",
                    back: "Mitigation: Use digital signatures to verify software/data integrity, ensure dependencies come from trusted repositories, use software supply chain security tools, implement review process for code changes, ensure CI/CD pipeline has proper segregation and configuration control, sign serialized data, and verify the integrity of software updates. Ensure your application verifies the integrity of critical data from untrusted sources."
                },
                {
                    front: "A09:2021 - What is Security Logging and Monitoring Failures?",
                    back: "Security Logging and Monitoring Failures involve inadequate logging, detection, monitoring, and active response. Without proper logging and monitoring, breaches cannot be detected. This occurs when security-relevant events are not logged, logs are not monitored effectively, or alerts are not properly generated or responded to."
                },
                {
                    front: "A09:2021 - Give examples of Security Logging and Monitoring Failures.",
                    back: "Auditable events not logged, logs not monitored for suspicious activity, logs only stored locally, inappropriate log levels, inadequate logging of sensitive information (PII), unclear log messages, logs not properly time-synchronized, and no alerting for suspicious activities."
                },
                {
                    front: "A09:2021 - How to prevent Security Logging and Monitoring Failures?",
                    back: "Mitigation: Implement logging for authentication, access control failures, and server-side input validation failures with sufficient context. Ensure logs are in a format that log management solutions can consume, ensure high-value transactions have audit trails, establish effective monitoring and alerting, and develop a response and recovery plan. Implement a security incident event management (SIEM) system or log analysis tools to correlate and analyze logs."
                },
                {
                    front: "A10:2021 - What is Server-Side Request Forgery (SSRF)?",
                    back: "SSRF flaws occur whenever a web application is fetching a remote resource without validating the user-supplied URL. It allows an attacker to coerce the application to send a crafted request to an unexpected destination, even when protected by a firewall, VPN, or other network access control list (ACL)."
                },
                {
                    front: "A10:2021 - Why is SSRF dangerous?",
                    back: "SSRF enables attackers to force the application to send requests to internal services behind firewalls, access metadata services in cloud environments (potentially exposing access keys), scan internal networks, and exploit vulnerable internal services that aren't hardened against attacks."
                },
                {
                    front: "A10:2021 - How to prevent SSRF vulnerabilities?",
                    back: "Mitigation: Implement network layer controls (segregate remote resource access functionality, enforce 'deny by default' firewall policies); apply application layer controls (sanitize and validate all client-supplied input data, enforce URL schema/port/destination with positive allow list); disable HTTP redirections; and do not send raw responses to clients. For high-risk applications, consider deploying a DNS filtering service or firewall rules to block all internal DNS lookups and traffic not destined for trusted hosts."
                },
                
                {
                    front: "Broken Access Control",
                    back:
                    "Definition: Broken Access Control occurs when authenticated users’ permissions are not correctly enforced, allowing attackers to access or modify resources (e.g., other users’ accounts, sensitive files).br\nExamples: Insecure Direct Object References (IDOR), path traversal attacks.<br><br>Mitigation: Implement strict access controls (deny by default), enforce record ownership, disable directory listing, rate limit API access, and perform regular security reviews and automated tests."
                },
                {
                    front: "Cryptographic Failures",
                    back:
                    "Definition: Cryptographic Failures occur when encryption is weak, misconfigured, or absent, causing exposure of sensitive data (e.g., transmission in cleartext or use of weak algorithms like MD5).<br><br>Mitigation: Use strong encryption algorithms (e.g., TLS 1.2/1.3, AES), manage keys securely, disable outdated protocols, and follow best practices for encryption implementation."
                },
                {
                    front: "Injection",
                    back:
                    "Definition: Injection vulnerabilities happen when untrusted data is sent to an interpreter as part of a command or query, allowing attackers to execute unintended commands (e.g., SQL, NoSQL, OS command injections).<br><br>Mitigation: Use parameterized queries (prepared statements), validate and sanitize all user input, use secure APIs/ORM frameworks, and employ input allowlisting."
                },
                {
                    front: "Insecure Design",
                    back:
                    "Definition: Insecure Design refers to fundamental flaws in the architecture or design of an application—such as missing authorization checks or flawed workflows—that can lead to vulnerabilities even before coding.<br><br>Mitigation: Integrate threat modeling and secure design patterns early in the development lifecycle; conduct design reviews and use security frameworks and guidelines."
                },
                {
                    front: "Security Misconfiguration",
                    back:
                    "Definition: Security Misconfiguration happens when systems or applications are deployed with unsafe default settings, unnecessary services are enabled, or configurations are left incomplete.<br><br>Mitigation: Harden configurations, remove unnecessary features or services, enforce the principle of least privilege, and use automated configuration management to verify settings."
                },
                {
                    front: "Vulnerable and Outdated Components",
                    back:
                    "Definition: This issue arises when an application uses outdated or known vulnerable li<br><br>aries, frameworks, or components that are subject to known exploits.<br><br>Mitigation: Continuously inventory and update all components, use Software Composition Analysis (SCA) tools, remove unused dependencies, and subscribe to security bulletins."
                },
                {
                    front: "Identification & Authentication Failures",
                    back:
                    "Definition: Failures in identification and authentication can allow attackers to bypass login mechanisms or hijack user sessions (e.g., weak passwords, poor session management).<br><br>Mitigation: Enforce strong multifactor authentication, use secure session management practices (with HttpOnly, Secure, and SameSite cookie flags), and implement account lockouts and strong password policies."
                },
                {
                    front: "Software & Data Integrity Failures",
                    back:
                    "Definition: These failures occur when the integrity of software or data isn’t protected, leading to tampering or unexpected modifications (e.g., untrusted plugins or unsafely updated code).<br><br>Mitigation: Verify code and data integrity with digital signatures, use secure update mechanisms, validate sources of external components, and regularly audit continuous integration/continuous deployment (CI/CD) pipelines."
                },
                {
                    front: "Security Logging & Monitoring Failures",
                    back:
                    "Definition: These failures occur when security events aren’t properly logged or monitored, hindering prompt detection of <br><br>eaches or abuse.<br><br>Mitigation: Implement comprehensive logging with context-rich data, deploy automated monitoring and alerting (e.g., SIEM systems), and review logs on a regular basis."
                },
                {
                    front: "Server-Side Request Forgery (SSRF)",
                    back:
                    "Definition: SSRF is an attack that tricks a server into fetching a remote resource without proper validation, potentially giving attackers access to internal systems or data.<br><br>Mitigation: Validate and sanitize user-supplied URLs, use allowlisting for permitted domains, disable unneeded redirection, and segment internal network resources from externally accessible systems."
                }
                ],
                fundamentals: [
                {
                    front: "What is the CIA triad?",
                    back: "The CIA triad refers to three core principles of information security: Confidentiality (ensuring data is accessible only to authorized users), Integrity (ensuring data remains accurate and unaltered), and Availability (ensuring systems and data are accessible when needed)."
                },
                {
                    front: "What is the Same-Origin Policy?",
                    back: "The Same-Origin Policy is a critical security mechanism that restricts how a document or script loaded from one origin can interact with resources from another origin. An origin is defined as a combination of URI scheme, host name, and port number."
                },
                {
                    front: "What are the components that define an origin in the Same-Origin Policy?",
                    back: "An origin is defined by three components: the URI scheme (like http or https), the host name (domain), and the port number. If any of these three are different, then the origin is considered different."
                },
                {
                    front: "What is Content Security Policy (CSP)?",
                    back: "Content Security Policy is an added layer of security that helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. It works by specifying which dynamic resources are allowed to load based on the source domain."
                },
                {
                    front: "Give examples of CSP directives.",
                    back: "Common CSP directives include: default-src (fallback for other resource types), script-src (valid JavaScript sources), style-src (valid CSS sources), img-src (valid image sources), connect-src (valid destinations for fetch/XHR/WebSocket), font-src, frame-src, and report-uri."
                },
                {
                    front: "What is Defense in Depth?",
                    back: "Defense in Depth is a security strategy that employs a layered approach with multiple defensive mechanisms. If one security control fails, others are in place to prevent a full breach. It includes technical, operational, and administrative controls across different security domains."
                },
                {
                    front: "What is the difference between authentication and authorization?",
                    back: "Authentication is the process of verifying who a user is (identity verification), while authorization is the process of verifying what specific resources a user has access to (permissions verification)."
                },
                {
                    front: "What is a Web Application Firewall (WAF)?",
                    back: "A Web Application Firewall is a security solution that filters, monitors, and blocks HTTP traffic to and from a web application. It protects web applications from various attacks like XSS, CSRF, SQL Injection, and more by inspecting HTTP requests and applying rules to filter out malicious traffic."
                },
                {
                    front: "What is the principle of least privilege?",
                    back: "The principle of least privilege states that a user, process, or program should be given only the minimum privileges necessary to complete its task. This limits the potential damage from accidents, errors, or unauthorized use."
                },
                {
                    front: "What is HTTPS and why is it important?",
                    back: "HTTPS (HTTP Secure) is an extension of HTTP that uses TLS/SSL encryption for secure communication over a computer network. It provides three key layers of protection: encryption (protecting the exchanged data), data integrity (preventing modification), and authentication (proving communication with the intended website)."
                },
                {
                    front: "What is input validation and why is it necessary?",
                    back: "Input validation is the process of checking that input data provided by users or other systems meets specified criteria. It's necessary to prevent malformed or malicious data from causing security issues like injection attacks, buffer overflows, or application crashes."
                },
                {
                    front: "What is the difference between a vulnerability, a threat, and a risk?",
                    back: "A vulnerability is a weakness in a system that could be exploited. A threat is a potential danger that might exploit a vulnerability. Risk is the potential for loss or damage when a threat exploits a vulnerability, calculated as the impact of the threat multiplied by the likelihood of it occurring."
                },
                {
                    front: "What is the OWASP organization?",
                    back: "The Open Web Application Security Project (OWASP) is a nonprofit foundation dedicated to improving software security. It operates as a community of security professionals who provide freely-available resources including documentation, tools, videos, and forums on application security."
                },
                {
                    front: "What is vulnerability scanning?",
                    back: "Vulnerability scanning is the process of automatically identifying security vulnerabilities in systems, networks, or applications. It uses specialized software to detect and report on known vulnerabilities, misconfigurations, or potential security weaknesses."
                },
                {
                    front: "What is the difference between vulnerability scanning and penetration testing?",
                    back: "Vulnerability scanning is automated, identifies known vulnerabilities without exploiting them, and typically covers a broader scope. Penetration testing is more targeted, involves active exploitation of vulnerabilities, includes manual techniques, and provides deeper insight into real-world impact. Pen testing often starts where vulnerability scanning ends."
                },
                {
                    front: "What is penetration testing?",
                    back: "Penetration testing (or pen testing) is a simulated cyber attack against a system to check for exploitable vulnerabilities. It goes beyond automated vulnerability scanning by actively attempting to exploit vulnerabilities to determine what an attacker might be able to access or damage."
                },
                {
                    front: "What is the difference between black box, white box, and gray box testing?",
                    back: "Black box testing is performed without knowledge of the internal workings of the system. White box testing is done with full knowledge of internal structure and design. Gray box testing is a combination, with limited knowledge of internals, similar to what a privileged insider might have."
                },
                {
                    front: "What is the SDLC and how does security fit into it?",
                    back: "The Software Development Life Cycle (SDLC) is the process of planning, creating, testing, and deploying software. Security should be integrated into each phase as part of a Secure SDLC: requirements (security requirements), design (threat modeling), implementation (secure coding), testing (security testing), and maintenance (security patches)."
                },
                {
                    front: "What is a security misconfiguration?",
                    back: "A security misconfiguration is an improper setup of security controls for a server, web application, database, or other IT asset. Examples include default credentials, unnecessary open ports, error messages with sensitive data, unpatched flaws, or running outdated software."
                },
                {
                    front: "What is the concept of 'shift left' in security?",
                    back: "Shift left refers to moving security testing and practices earlier in the software development lifecycle. Rather than addressing security issues after development or deployment, shift left emphasizes integrating security from the beginning with requirements gathering, design, and early testing phases."
                },
                {
                    front: "What is the difference between symmetric and asymmetric encryption?",
                    back: "Symmetric encryption uses the same key for both encryption and decryption (faster but key distribution is challenging). Asymmetric encryption uses different keys for encryption (public key) and decryption (private key), solving the key distribution problem but generally slower."
                },
                {
                    front: "What is the principle of defense in depth?",
                    back: "Defense in depth involves implementing multiple layers of security controls throughout a system, so that if one security measure fails, others are in place to prevent a full breach. It includes physical, technical, and administrative controls, and applies multiple different types of controls at different levels of the system."
                },
                {
                    front: "What is security through obscurity and why is it problematic?",
                    back: "Security through obscurity relies on secrecy of design, implementation, or configuration for security rather than robust security controls. It's problematic because once the secret is discovered, the system is vulnerable. Good security should remain effective even if the attacker knows everything about the system except the keys."
                },
                {
                    front: "What is input sanitization and how does it differ from validation?",
                    back: "Input sanitization modifies user input to ensure it's safe for processing (removing/replacing dangerous characters). Input validation checks if data meets criteria without changing it (accepting or rejecting). Sanitization transforms potentially malicious data into safe format, while validation determines if data is acceptable in its current form."
                },
                {
                    front: "What is the difference between SAST and DAST?",
                    back: "Static Application Security Testing (SAST) analyzes source code for security vulnerabilities without executing the application. Dynamic Application Security Testing (DAST) tests running applications by attacking from the outside. SAST finds implementation bugs early; DAST finds runtime and environment issues like misconfigurations."
                },
                {
                    front: "What is threat modeling?",
                    back: "Threat modeling is a structured process of identifying potential threats to a system and determining their potential impact. It involves identifying assets, threat actors, attack vectors, and vulnerabilities, then prioritizing risks and developing mitigation strategies. Common methodologies include STRIDE, PASTA, and DREAD."
                },
                {
                    front: "What are security requirements?",
                    back: "Security requirements define the security controls and measures needed to protect a system or application. They include functional requirements (authentication, authorization, encryption) and non-functional requirements (compliance, audit controls, performance under attack). They should be specific, measurable, and testable."
                },
                {
                    front: "What is secure code review?",
                    back: "Secure code review is the systematic examination of source code to identify security vulnerabilities like SQL injection, XSS, buffer overflows, or logic flaws. It can be manual (performed by security experts) or automated (using SAST tools), and ideally combines both approaches for comprehensive coverage."
                },
                {
                    front: "What is the security impact of third-party components?",
                    back: "Third-party components may introduce security risks through: known vulnerabilities, insufficient vetting, lack of patches, unexpected behavior, supply chain attacks, data leakage, excessive permissions, or poor integration practices. Mitigation requires proper inventory, vetting, monitoring, and update policies."
                }
            ],
            tools: [
                {
                    front: "What is Burp Suite used for?",
                    back: "Burp Suite is an integrated platform for performing security testing of web applications. It contains various tools that work together to support the entire testing process, from initial mapping and analysis of an application's attack surface to finding and exploiting security vulnerabilities."
                },
                {
                    front: "What are the main components of Burp Suite?",
                    back: "Burp Suite includes: Proxy (intercepts and modifies requests/responses), Scanner (automated vulnerability detection), Intruder (customized attack automation), Repeater (manual request modification and resending), Decoder (encode/decode data), Comparer (compare data), and Sequencer (analyze randomness)."
                },
                {
                    front: "How is Burp Intruder used in penetration testing?",
                    back: "Burp Intruder automates customized attacks by taking a base request and replacing specific parts with payloads. Its attack types include: Sniper (tests one payload position), Battering ram (puts same payload in multiple positions), Pitchfork (iterates through multiple payload sets simultaneously), and Cluster bomb (tries all combinations of payloads). It's used for brute forcing, fuzzing, and enumerating resources."
                },
                {
                    front: "What is OWASP ZAP (Zed Attack Proxy)?",
                    back: "OWASP ZAP is an open-source web application security scanner. It automatically finds security vulnerabilities in web applications during development and testing. It acts as a 'man-in-the-middle proxy' between the tester's browser and the web application."
                },
                {
                    front: "How does ZAP differ from Burp Suite?",
                    back: "ZAP is fully open-source and free, while Burp has free and paid versions with more features in the paid version. ZAP provides more automated scanning in the free version, while Burp Professional offers more comprehensive scanning. ZAP has a strong community-driven development model, while Burp is commercial software."
                },
                {
                    front: "What is Nmap and what is it used for?",
                    back: "Nmap (Network Mapper) is an open-source tool for network discovery and security auditing. It uses IP packets to determine what hosts are available on the network, what services those hosts are offering, what operating systems they're running, what type of packet filters/firewalls are in use, and more."
                },
                {
                    front: "What are common Nmap scan types?",
                    back: "Common Nmap scan types include: TCP SYN scan (-sS, half-open scanning), TCP connect scan (-sT, complete connections), UDP scan (-sU), FIN scan (-sF, sends a FIN packet), Ping scan (-sP, just determine if hosts are online), and Version detection (-sV, determines service versions)."
                },
                {
                    front: "What is Nmap scripting engine (NSE) and how is it used?",
                    back: "NSE allows users to write and share scripts to automate a wide variety of networking tasks. Scripts are organized by categories like auth, vuln, exploit, discovery. Example uses include detecting vulnerabilities, performing brute force attacks, gathering additional service information, and even active exploitation. Activated using --script option."
                },
                {
                    front: "What is Metasploit Framework?",
                    back: "Metasploit Framework is an open-source penetration testing platform that enables you to find, exploit, and validate vulnerabilities. It provides a complete environment for penetration testing and exploit development, including a database of known exploits."
                },
                {
                    front: "What are the key components of Metasploit?",
                    back: "Key components include: Exploits (code to take advantage of vulnerabilities), Payloads (code that runs after exploitation), Auxiliaries (scanning, fuzzing, sniffing tools), Post-exploitation modules (for maintaining access), and the msfconsole (command interface)."
                },
                {
                    front: "What types of payloads does Metasploit offer and how do they differ?",
                    back: "Metasploit offers: Singles (self-contained, run and exit), Stagers (small payloads that establish connection and download larger stage), Stages (downloaded by stagers, provide advanced features), Meterpreter (advanced payload with in-memory DLL injection), and Non-Meterpreter (simpler command shells). They differ in functionality, size, stealth, and stability."
                },
                {
                    front: "What is Nikto?",
                    back: "Nikto is an open-source web server scanner that performs comprehensive tests against web servers for multiple items, including over 6700 potentially dangerous files/programs, outdated versions of servers, and version-specific problems on over 270 servers."
                },
                {
                    front: "What is Wireshark used for?",
                    back: "Wireshark is a network protocol analyzer that lets you capture and interactively browse the traffic running on a computer network. It provides detailed inspection of hundreds of protocols, live capture and offline analysis, and deep inspection of many protocols."
                },
                {
                    front: "How do you use display filters in Wireshark to focus on specific traffic?",
                    back: "Wireshark display filters use syntax like 'protocol.field == value'. Common examples: 'http' (show only HTTP), 'ip.addr == 192.168.1.1' (traffic to/from specific IP), 'tcp.port == 443' (HTTPS traffic), 'http.request.method == \"GET\"' (HTTP GET requests), and '!(arp or dns)' (exclude ARP and DNS). Filters can be combined with 'and', 'or', and 'not'."
                },
                {
                    front: "What is SQLmap?",
                    back: "SQLmap is an open-source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over database servers. It features a powerful detection engine, many niche features for the ultimate penetration tester, and a broad range of switches for database fingerprinting, data fetching, and accessing the underlying file system."
                },
                {
                    front: "What are key SQLmap options and techniques?",
                    back: "Key options include: --url (target URL), --data (POST data), --cookie (session cookies), --dbs (enumerate databases), --tables (list tables), --dump (extract data), --os-shell (get OS command execution), --technique (specify injection techniques like BEUSTQ), --risk/--level (control test thoroughness), and --proxy (route through proxy)."
                },
                {
                    front: "What is John the Ripper?",
                    back: "John the Ripper is a free password cracking software tool designed to detect weak Unix passwords. It can automatically detect password hash types and includes a customizable cracker. It combines several cracking modes and is available for many operating systems."
                },
                {
                    front: "What is OWASP Amass?",
                    back: "OWASP Amass performs network mapping of attack surfaces and external asset discovery using open source information gathering and active reconnaissance techniques. It helps security professionals identify potential security vulnerabilities by discovering an organization's external attack surface."
                },
                {
                    front: "What is Aircrack-ng?",
                    back: "Aircrack-ng is a network software suite consisting of a detector, packet sniffer, WEP and WPA/WPA2-PSK cracker and analysis tool for 802.11 wireless LANs. It works with any wireless network interface controller whose driver supports raw monitoring mode."
                },
                {
                    front: "What is Kali Linux?",
                    back: "Kali Linux is a Debian-derived Linux distribution designed for digital forensics and penetration testing. It is maintained and funded by Offensive Security. It comes pre-installed with numerous penetration testing tools, making it a popular choice for security professionals."
                },
                {
                    front: "What is Hydra?",
                    back: "Hydra is a parallelized login cracker which supports numerous protocols to attack. It is very fast and flexible, and new modules are easy to add. It can perform rapid dictionary attacks against more than 50 protocols, including telnet, FTP, HTTP, HTTPS, SMB, databases, LDAP, and more."
                },
                {
                    front: "What are some common Hydra command options?",
                    back: "Common Hydra options include: -l (single username) or -L (username list file), -p (single password) or -P (password list file), -t (number of parallel connections), -V (verbose mode), -f (stop after first valid credential pair), and protocol-specific options like http-post-form for web form attacks."
                },
                {
                    front: "What is Dirb/Dirbuster?",
                    back: "Dirb/Dirbuster are web content scanning tools designed to find hidden directories and files by performing dictionary-based attacks against web servers. They use wordlists to find directories and files that are not linked directly from the website but are still accessible."
                },
                {
                    front: "What is Maltego?",
                    back: "Maltego is an open-source intelligence (OSINT) and graphical link analysis tool for gathering and connecting information for investigative tasks. It allows you to mine data from various sources, create visual link graphs, and identify relationships between information from different sources on the internet."
                },
                {
                    front: "What is BeEF (Browser Exploitation Framework)?",
                    back: "BeEF is a penetration testing tool focused on web browsers. It allows a penetration tester to assess the security posture of a target by using client-side attack vectors. It hooks one or more web browsers as beachheads for launching directed command modules and further attacks against the system."
                },
                {
                    front: "What is Snort?",
                    back: "Snort is an open-source network intrusion prevention system (NIPS) and network intrusion detection system (NIDS). It can perform real-time traffic analysis and packet logging on IP networks, as well as protocol analysis, content searching/matching, and detection of various attacks and probes."
                },
                {
                    front: "What is the difference between gobuster, dirb, and dirbuster?",
                    back: "All three tools bruteforce directories and files, but with differences: Gobuster is written in Go, has faster performance due to threading, and has additional features for DNS and vhost enumeration. Dirb is command-line only, handles cookies easily, and has good recursive scanning. Dirbuster has a GUI interface and more detailed reporting but is no longer actively maintained."
                },
                {
                    front: "What is Hashcat?",
                    back: "Hashcat is the world's fastest password recovery tool, supporting five unique attack modes for over 300 highly-optimized hashing algorithms. It leverages GPU acceleration to achieve high speeds, supports various hash types (MD5, SHA, bcrypt, etc.), and offers multiple attack modes including dictionary, rule-based, brute-force, and hybrid attacks."
                },
                {
                    front: "What is theHarvester and how is it used in reconnaissance?",
                    back: "theHarvester is an OSINT tool used to gather email accounts, subdomain names, virtual hosts, open ports, and employee names from different public sources like search engines and PGP key servers. It helps in the reconnaissance phase by creating a profile of the target organization's digital footprint without actively engaging with target systems."
                }
            ],
                attacks: [
                {
                    front: "Cross-Site Scripting (XSS)",
                    back:
                    "Definition: XSS is a vulnerability that allows attackers to inject and execute malicious client-side scripts in other users’ <br><br>owsers. Variants include Stored, Reflected, and DOM-based XSS.<br><br>Mitigation: Implement contextual output encoding, sanitize user input, deploy a Content Security Policy (CSP), and set the HttpOnly flag for cookies to restrict client-side script access."
                },
                {
                    front: "SQL Injection",
                    back:
                    "Definition: SQL Injection is an attack where malicious SQL commands are inserted into an entry field for execution, allowing unauthorized data access or manipulation.<br><br>Mitigation: Use parameterized queries and prepared statements, validate inputs on the server-side, use ORM li<br><br>aries that enforce parameter binding, and apply least privilege to database accounts."
                },
                {
                    front: "Cross-Site Request Forgery (CSRF)",
                    back:
                    "Definition: CSRF is an attack that forces an authenticated user to perform an unwanted action on a web application, such as changing account details or making transactions.<br><br>Mitigation: Implement anti-CSRF tokens, set cookies with the SameSite attribute, verify the Referer header, and require reauthentication for sensitive operations."
                },
                {
                    front: "Man-in-the-Middle (MitM)",
                    back:
                    "Definition: A MitM attack involves an attacker secretly intercepting and possibly altering the communication between two parties who believe they are communicating directly.<br><br>Mitigation: Use strong encryption (TLS/SSL), enable certificate pinning, enforce HSTS, and educate users about certificate warnings on unsecured networks."
                },
                {
                    front: "Denial of Service (DoS) / Distributed Denial of Service (DDoS)",
                    back:
                    "Definition: DoS/DDoS attacks aim to make systems or networks unavailable by overwhelming them with traffic or requests.<br><br>Mitigation: Implement rate limiting, use load balancing and traffic filtering, deploy anti-DDoS services (such as CDNs or specialized appliances), and design systems with scalability in mind."
                },
                {
                    front: "XML External Entity (XXE) Processing",
                    back:
                    "Definition: XXE vulnerabilities occur when XML parsers process external entity references, potentially allowing attackers to read sensitive files or cause denial of service.<br><br>Mitigation: Disable external entity processing in XML parsers, validate XML input against a strict schema, and prefer simpler data formats like JSON when possible."
                },
                {
                    front: "Path Traversal",
                    back:
                    "Definition: Path Traversal (Directory Traversal) attacks exploit vulnerabilities in file path processing to access files or directories outside the intended scope.<br><br>Mitigation: Validate and sanitize all file path inputs, normalize file paths, and enforce strict file system permissions and allowlists."
                },
                {
                    front: "Insecure Deserialization",
                    back:
                    "Definition: Insecure Deserialization occurs when untrusted data is used to reconstitute objects without proper validation, leading to remote code execution or logic tampering.<br><br>Mitigation: Validate serialized data, enforce strict type constraints, use integrity checks (e.g., digital signatures), and consider using safer formats (like JSON) that don’t allow complex object graphs."
                },
                {
                    front: "Business Logic Attacks",
                    back:
                    "Definition: Business Logic Attacks abuse the intended functionality of an application to achieve malicious goals (e.g., price manipulation or unauthorized discounts), without necessarily exploiting a technical bug.<br><br>Mitigation: Thoroughly review application workflows, enforce consistent business rules with both client- and server-side validation, and perform regular threat modeling."
                },
                {
                    front: "Clickjacking",
                    back:
                    "Definition: Clickjacking tricks users into clicking on hidden or disguised elements on a webpage, often leading to unintended actions like submitting forms or revealing information.<br><br>Mitigation: Implement X-Frame-Options or Content Security Policy (frame-ancestors directive), and consider adding extra user confirmations for sensitive actions."
                },
                {
                    front: "Remote Code Execution (RCE)",
                    back:
                    "Definition: RCE allows an attacker to run arbitrary commands or code on a target machine remotely, often leading to full system compromise.<br><br>Mitigation: Validate and sanitize all input, avoid dangerous functions (e.g., eval or direct command execution), enforce the least privilege principle, and keep systems patched."
                },
                {
                    front: "Race Condition Vulnerabilities",
                    back:
                    "Definition: Race conditions occur when the system’s security checks and subsequent operations are not performed atomically, allowing timing-based exploitation.<br><br>Mitigation: Employ proper synchronization and atomic operations, validate outcomes after actions, and use thread-safe coding practices."
                },
                {
                    front: "Buffer Overflow Attacks",
                    back:
                    "Definition: Buffer overflow attacks occur when a program writes more data to a buffer than it can hold, overwriting adjacent memory and possibly allowing code execution.<br><br>Mitigation: Use safe programming languages or li<br><br>aries that include bounds checking, apply compiler-based protections (e.g., stack canaries), and perform regular code audits."
                },
                {
                    front: "HTTP Response Splitting and Cache Poisoning",
                    back:
                    "Definition: HTTP Response Splitting abuses header injection to create multiple responses from one request, whereas Cache Poisoning manipulates the caching mechanism to serve malicious content.<br><br>Mitigation: Sanitize all header inputs, enforce strict HTTP standards, and configure caching policies to ensure that dynamic content is not inadvertently cached."
                }
                ],
                bestpractices: [
                {
                    front: "What is Secure Software Development Life Cycle (SSDLC)?",
                    back: "SSDLC integrates security testing and best practices into each phase of the software development lifecycle. It includes practices like threat modeling, code reviews, security testing, and security requirement analysis to build security into applications from the beginning rather than adding it later."
                },
                {
                    front: "What are security headers and why are they important?",
                    back: "Security headers are HTTP response headers that your application can use to increase the security of your application. They tell browsers how to behave when handling your site's content and can help mitigate common web vulnerabilities like XSS, clickjacking, and data injection attacks."
                },
                {
                    front: "List some important security headers and their purpose.",
                    back: "Content-Security-Policy: Controls resources the browser is allowed to load. X-Frame-Options: Prevents clickjacking. Strict-Transport-Security: Forces HTTPS connections. X-Content-Type-Options: Prevents MIME-type sniffing. X-XSS-Protection: Enables browser's XSS filters. Referrer-Policy: Controls referrer information. Permissions-Policy: Controls browser features."
                },
                {
                    front: "What is the purpose of input sanitization?",
                    back: "Input sanitization is the process of removing or replacing characters in user input that could be harmful. Unlike validation (which rejects improper input), sanitization attempts to clean the data to make it safe for processing, removing potential attack vectors like script tags or SQL commands."
                },
                {
                    front: "What is the importance of proper error handling?",
                    back: "Proper error handling prevents applications from revealing sensitive information in error messages. Detailed error messages can expose implementation details, stack traces, database structures, or other internal workings that attackers can use to plan more targeted attacks."
                },
                {
                    front: "What steps should be taken for secure error handling?",
                    back: "Implement generic error messages for users while logging detailed errors server-side, use custom error pages, avoid revealing system information, version numbers, or stack traces in production, establish different handling for different error types, log errors securely with proper context, and implement graceful failure that maintains security controls."
                },
                {
                    front: "What is the difference between hashing and encryption?",
                    back: "Hashing transforms data into a fixed-length string (hash) that cannot be reversed back to the original data. Encryption transforms data into a different format that can be reversed back to the original data using a key. Hashing is used for verification (like passwords), while encryption is used when data needs to be retrieved later."
                },
                {
                    front: "What are salts in password security?",
                    back: "A salt is random data added to a password before hashing. It creates unique hashes even for identical passwords, preventing rainbow table attacks and ensuring that even if two users have the same password, their stored hashes will be different."
                },
                {
                    front: "Why should passwords be salted and hashed instead of just hashed?",
                    back: "Salting protects against rainbow table attacks and dictionary attacks by ensuring that identical passwords don't produce identical hashes. Without salts, attackers could use precomputed tables of common password hashes to quickly crack multiple passwords. Salts ensure each password hash is unique even if the passwords are the same."
                },
                {
                    front: "What is security by obscurity and why is it problematic?",
                    back: "Security by obscurity is the reliance on the secrecy of design, implementation, or other aspects of a system for security. It's problematic because it provides a false sense of security - once the 'secret' is discovered, the system is completely vulnerable. Security should rely on well-tested algorithms and proper implementation, not secrecy."
                },
                {
                    front: "What is certificate pinning?",
                    back: "Certificate pinning is the practice of hardcoding or storing the expected certificate or public key for a server in your application. It adds an extra layer of security by ensuring that your app only communicates with the intended server, even if an attacker presents a valid but unexpected certificate."
                },
                {
                    front: "What is STRIDE threat modeling?",
                    back: "STRIDE is a threat modeling methodology that categorizes different types of threats: Spoofing (impersonating something or someone), Tampering (modifying data or code), Repudiation (claiming not to have performed an action), Information disclosure (exposing information), Denial of service (denying or degrading service), and Elevation of privilege (gaining unauthorized access)."
                },
                {
                    front: "What is the principle of fail-secure vs. fail-open?",
                    back: "Fail-secure (or fail-safe) means that if a system fails, it defaults to a secure state (e.g., denying access). Fail-open means that if a system fails, it defaults to an open state (e.g., allowing access). Security-critical systems should be designed to fail-secure to prevent unauthorized access during failures."
                },
                {
                    front: "What is the principle of separation of duties?",
                    back: "Separation of duties is a principle where multiple people are required to complete a sensitive task, preventing any single person from having excessive control. For example, the person who approves purchases should be different from the person who makes purchases, reducing the risk of fraud or error."
                },
                {
                    front: "What is the principle of defense in depth?",
                    back: "Defense in depth involves implementing multiple layers of security controls throughout a system. The idea is that if one security measure fails, others are in place to prevent a full breach. This includes combining different types of controls (preventive, detective, and corrective) at various levels (network, host, application, data)."
                },
                {
                    front: "What is secure code review?",
                    back: "Secure code review is the systematic examination of source code to identify security vulnerabilities and ensure adherence to security best practices and requirements. It can be manual (performed by humans) or automated (using static analysis tools), and ideally combines both approaches."
                },
                {
                    front: "What is the principle of zero trust?",
                    back: "Zero trust is a security concept that assumes no user or system, whether inside or outside the network perimeter, should be trusted by default. It requires continuous verification of identity and privileges, strict access controls, and least privilege enforcement. The philosophy is 'never trust, always verify.'"
                },
                {
                    front: "What are static and dynamic application security testing (SAST and DAST)?",
                    back: "SAST analyzes source code or compiled versions of code to find security vulnerabilities without executing the application. DAST analyzes a running application by attacking it from the outside, similar to how an attacker would. Both are important parts of a comprehensive security testing strategy."
                },
                {
                    front: "What is secure session management?",
                    back: "Secure session management involves properly creating, storing, and invalidating user sessions. Best practices include: using strong session IDs, secure cookies (with HttpOnly, Secure, and SameSite flags), proper session timeouts, regenerating IDs after authentication, and invalidating sessions on logout."
                },
                {
                    front: "What is the OWASP ASVS (Application Security Verification Standard)?",
                    back: "ASVS is a framework that provides a basis for testing web application security controls and also provides developers with a list of requirements for secure development. It defines three security verification levels (with increasing rigor) and covers authentication, session management, access control, validation, and other security areas."
                },
                {
                    front: "What are some secure password storage practices?",
                    back: "Use strong adaptive hashing algorithms (bcrypt, Argon2, PBKDF2), add unique salts to passwords before hashing, implement proper key stretching with work factors, store hashes rather than plaintext passwords, use pepper (secret key) for additional security, and enforce strong password policies."
                },
                {
                    front: "What is Secure Coding and why is it important?",
                    back: "Secure coding involves writing code that's resistant to attack, following principles like input validation, proper authentication, error handling, and secure defaults. It's important because security vulnerabilities are often introduced at the code level, and retrofitting security is more expensive and less effective than building it in from the beginning."
                },
                {
                    front: "What is the principle of minimizing attack surface?",
                    back: "Minimizing attack surface involves reducing the number of entry points and exposed components available to attackers. This includes removing unnecessary features, closing unused ports, disabling unneeded services, limiting user privilege, reducing code complexity, and decreasing the amount of exposed code or API endpoints."
                },
                {
                    front: "What is privilege separation?",
                    back: "Privilege separation involves dividing a system into components with different privilege levels, where each component has only the privileges it needs to function. This limits the impact of a security breach, as a compromise in one component doesn't automatically grant access to the entire system."
                },
                {
                    front: "What is the 'secure by default' principle?",
                    back: "Secure by default means that the default configuration of a system or application should be the most secure configuration possible. Users shouldn't have to take additional steps to secure the system; instead, they should have to explicitly choose to reduce security if they need less restrictive functionality."
                },
                {
                    front: "What are security controls and what are the different types?",
                    back: "Security controls are safeguards designed to reduce security risks. Types include: Preventive controls (prevent incidents), Detective controls (identify incidents), Corrective controls (restore after incidents), Administrative controls (policies/procedures), Technical controls (hardware/software mechanisms), and Physical controls (facility/environmental protections)."
                }
            ],
                appsec: [
                {
                    front: "Blacklist vs. Whitelist Input Validation",
                    back:
                    "Definition: Blacklisting (denylisting) blocks known malicious inputs, while whitelisting (allowlisting) permits only explicitly approved values, making the latter generally more secure.<br><br>Mitigation: Prefer whitelisting for input validation to ensure only expected data is accepted, and employ multiple layers of checks."
                },
                {
                    front: "Server-Side Validation",
                    back:
                    "Definition: Server-side validation verifies and sanitizes data on the server, protecting against bypasses that can occur on the client side.<br><br>Mitigation: Always enforce input validation on the server even when client-side checks are present; use robust validation li<br><br>aries."
                },
                {
                    front: "Web Cache Poisoning",
                    back:
                    "Definition: Web Cache Poisoning occurs when an attacker manipulates caching mechanisms to serve malicious responses to multiple users.<br><br>Mitigation: Properly configure cache keys, validate all user inputs affecting cacheable content, and set strict Cache-Control headers."
                },
                {
                    front: "Prototype Pollution",
                    back:
                    "Definition: Prototype pollution is a vulnerability in JavaScript that enables attackers to modify the global object prototype, impacting many parts of an application.<br><br>Mitigation: Use safe coding patterns, avoid merging untrusted objects blindly, and employ li<br><br>aries designed to mitigate this issue."
                },
                {
                    front: "CSP Nonce",
                    back:
                    "Definition: A CSP nonce is a randomly generated value added to allowed inline scripts and included in the Content-Security-Policy header to let only those scripts run.<br><br>Mitigation: Generate a unique nonce for each page load, apply it to all allowed script tags, and enforce it via the CSP header."
                },
                {
                    front: "Same-Origin Policy & CORS",
                    back:
                    "Definition: The Same-Origin Policy restricts resource access to the same domain; CORS provides controlled relaxation of this policy for trusted external resources.<br><br>Mitigation: Configure CORS to allow only trusted origins, and enforce robust server-side validation of cross-origin requests."
                },
                {
                    front: "HSTS (HTTP Strict Transport Security)",
                    back:
                    "Definition: HSTS instructs <br><br>owsers to use HTTPS exclusively when connecting to a website, mitigating the risk of downgrade attacks and cookie hijacking.<br><br>Mitigation: Enable HSTS on the web server with a suitable max-age and include subdomain directives when appropriate."
                },
                {
                    front: "Subdomain Takeover",
                    back:
                    "Definition: Subdomain takeover occurs when a subdomain points to an abandoned or unclaimed service, allowing an attacker to host malicious content under that subdomain.<br><br>Mitigation: Regularly audit DNS configurations, remove or secure unused subdomains, and monitor DNS records for unauthorized changes."
                },
                {
                    front: "JWT Security",
                    back:
                    "Definition: JWTs (JSON Web Tokens) can be vulnerable to issues like weak signing, lack of expiration checks, and algorithm manipulation.<br><br>Mitigation: Validate JWT signatures properly, enforce expiration policies, use strong secret keys or asymmetric cryptography, and avoid storing sensitive data in tokens."
                },
                {
                    front: "NoSQL Injection",
                    back:
                    "Definition: NoSQL injection targets NoSQL databases by injecting malicious query selectors into database queries.<br><br>Mitigation: Use parameterized queries or query builders, validate and sanitize all inputs, and enforce strict schema definitions."
                },
                {
                    front: "GraphQL Security",
                    back:
                    "Definition: GraphQL introduces risks such as overfetching, complex nested queries, and injection attacks if not properly controlled.<br><br>Mitigation: Limit query depth and complexity, validate all inputs, disable introspection in production, and implement fine-grained authorization."
                },
                {
                    front: "SSRF in Application Security",
                    back:
                    "Definition: SSRF can be exploited via insecure server-side code to access internal resources.<br><br>Mitigation: Sanitize and validate URLs, use strict allowlists for outgoing requests, and segregate internal networks from publicly accessible servers."
                },
                {
                    front: "HTTP Request Smuggling",
                    back:
                    "Definition: HTTP Request Smuggling manipulates how front-end and back-end servers interpret HTTP messages, creating ambiguities that can be exploited.<br><br>Mitigation: Use consistent HTTP parsers, set explicit Content-Length or Transfer-Encoding headers, and keep servers updated with the latest patches."
                },
                {
                    front: "API Security",
                    back:
                    "Definition: API security focuses on protecting access to APIs from abuse and unauthorized use.<br><br>Mitigation: Employ strong authentication and authorization (e.g., OAuth 2.0), validate inputs, enforce rate limiting, and secure endpoints with HTTPS."
                },
                {
                    front: "Complete Mediation",
                    back:
                    "Definition: Complete mediation requires that every access to a resource is verified (rather than relying on cached permissions).<br><br>Mitigation: Revalidate every access request, avoid caching security decisions, and ensure all entry points enforce authorization."
                }
                ],
                cryptography: [
                {
                    front: "Encoding vs. Encryption vs. Hashing",
                    back:
                    "Definition: Encoding converts data for transmission or storage (not secure), encryption scrambles data with a reversible key for confidentiality, and hashing provides a one-way transformation for integrity and authentication.<br><br>Mitigation: Use encryption for data privacy and apply strong, salted hashing techniques for data integrity."
                },
                {
                    front: "Symmetric Encryption",
                    back:
                    "Definition: Symmetric encryption uses the same key to encrypt and decrypt data, making it fast but requiring secure key management.<br><br>Mitigation: Use strong algorithms (e.g., AES), securely store and exchange keys, and periodically rotate keys."
                },
                {
                    front: "Asymmetric Encryption",
                    back:
                    "Definition: Asymmetric encryption uses a public and a private key, solving key exchange issues but requiring more computational power.<br><br>Mitigation: Use robust algorithms (e.g., RSA, ECC), protect the private key, and apply certificate-based authentication."
                },
                {
                    front: "Hybrid Cryptosystems",
                    back:
                    "Definition: Hybrid cryptosystems combine asymmetric and symmetric encryption to benefit from secure key exchange and efficient data encryption.<br><br>Mitigation: Securely exchange the symmetric key using asymmetric encryption and then encrypt data using a strong symmetric algorithm."
                },
                {
                    front: "Hash Functions & Collisions",
                    back:
                    "Definition: Hash functions generate fixed-length outputs from variable input; collisions occur when different inputs produce the same hash.<br><br>Mitigation: Use collision-resistant hash functions and add unique salts to each input to prevent precomputed attacks."
                },
                {
                    front: "Salting in Password Hashing",
                    back:
                    "Definition: Salting involves adding random data to passwords before hashing, ensuring that identical passwords produce unique hashes.<br><br>Mitigation: Generate a unique salt per user and store it alongside the hashed password; use secure hashing algorithms like bcrypt or Argon2."
                },
                {
                    front: "Rainbow Table Attacks",
                    back:
                    "Definition: Rainbow table attacks use precomputed hash tables to reverse weak hashes.<br><br>Mitigation: Employ salting and use modern, computationally expensive hashing algorithms to make such attacks impractical."
                },
                {
                    front: "MD5 Insecurity",
                    back:
                    "Definition: MD5 is considered insecure because it is vulnerable to collision and preimage attacks, making it unsuitable for security-sensitive applications.<br><br>Mitigation: Replace MD5 with modern hash functions such as SHA-256 for integrity or bcrypt/Argon2 for password storage."
                },
                {
                    front: "Strong Password Hashing Algorithms",
                    back:
                    "Definition: Strong password hashing algorithms (e.g., bcrypt, Argon2, PBKDF2) are designed to be slow and resource-intensive, slowing down <br><br>ute-force attacks.<br><br>Mitigation: Use adaptive hashing algorithms with a configurable work factor and unique salts for each password."
                },
                {
                    front: "HTTPS and TLS/SSL",
                    back:
                    "Definition: HTTPS is HTTP secured by TLS/SSL, ensuring encrypted communication, data integrity, and authenticity.<br><br>Mitigation: Configure TLS properly (using TLS 1.2/1.3), select strong cipher suites, and regularly update server certificates."
                },
                {
                    front: "Digital Certificates & CAs",
                    back:
                    "Definition: Digital certificates issued by trusted Certificate Authorities (CAs) verify public keys and secure communications over networks.<br><br>Mitigation: Use certificates from reputable CAs, validate certificate chains, and consider certificate pinning for critical applications."
                },
                {
                    front: "Perfect Forward Secrecy (PFS)",
                    back:
                    "Definition: PFS ensures that past communications remain secure even if long-term keys are compromised by using temporary, ephemeral session keys.<br><br>Mitigation: Enforce ephemeral key exchanges (DHE/ECDHE) in TLS configurations to provide PFS."
                },
                {
                    front: "Digital Signatures",
                    back:
                    "Definition: Digital signatures use cryptographic techniques to authenticate the source and integrity of digital data.<br><br>Mitigation: Use strong signature algorithms, protect private signing keys, and verify signatures against trusted public keys."
                },
                {
                    front: "TLS vs. SSL",
                    back:
                    "Definition: TLS is the successor to SSL and offers improved security; SSL versions are deprecated due to known vulnerabilities.<br><br>Mitigation: Disable all SSL protocols and configure systems to use TLS 1.2 or 1.3 exclusively."
                },
                {
                    front: "HMAC",
                    back:
                    "Definition: HMAC (Hash-based Message Authentication Code) provides data integrity and authenticity by combining a cryptographic hash function with a secret key.<br><br>Mitigation: Use HMAC with secure hash functions and properly secure the secret keys."
                },
                {
                    front: "Key Stretching",
                    back:
                    "Definition: Key stretching techniques (e.g., PBKDF2, bcrypt, Argon2) deliberately increase the computational effort required to guess weak keys or passwords.<br><br>Mitigation: Incorporate key stretching in password hashing to delay <br><br>ute-force attempts."
                },
                {
                    front: "RSA",
                    back:
                    "Definition: RSA is an asymmetric encryption algorithm widely used for secure data transmission and digital signatures, based on the difficulty of factoring large numbers.<br><br>Mitigation: Use sufficiently large key sizes and secure padding mechanisms to ensure RSA remains resistant to attacks."
                },
                {
                    front: "AES",
                    back:
                    "Definition: AES (Advanced Encryption Standard) is a symmetric encryption algorithm used worldwide to secure data with key lengths of 128, 192, or 256 bits.<br><br>Mitigation: Implement AES in secure modes (e.g., GCM, CBC with IVs) and keep keys secure."
                },
                {
                    front: "Cryptographic Nonces",
                    back:
                    "Definition: A nonce is a unique number used once in a cryptographic communication to prevent replay attacks.<br><br>Mitigation: Generate secure, random nonces and ensure they are never reused in the same context."
                },
                {
                    front: "Elliptic Curve Cryptography (ECC)",
                    back:
                    "Definition: ECC provides similar security to traditional asymmetric algorithms like RSA but with shorter key lengths and improved efficiency.<br><br>Mitigation: Use recommended ECC parameters (e.g., curves such as secp256r1), and protect private keys with the same care as other sensitive credentials."
                },
                {
                    front: "Public Key Infrastructure (PKI)",
                    back:
                    "Definition: PKI is the framework for managing digital certificates and public-key encryption, enabling secure communications across untrusted networks.<br><br>Mitigation: Ensure robust certificate issuance, revocation, and management practices, and validate all certificate chains."
                },
                {
                    front: "Key Derivation Functions (KDF)",
                    back:
                    "Definition: KDFs generate secure cryptographic keys from a base secret (e.g., a password) and are used to resist <br><br>ute-force attacks.<br><br>Mitigation: Use KDFs such as PBKDF2, Argon2, or HKDF with proper parameters to ensure derived keys are strong and secure."
                }
                ],
                authentication: [
                {
                    front: "Multi-Factor Authentication (MFA)",
                    back:
                    "Definition: MFA requires users to provide two or more independent proofs (factors) of identity before being granted access (e.g., something you know, have, or are).<br><br>Mitigation: Implement MFA on critical systems to reduce the risk of unauthorized access due to compromised credentials."
                },
                {
                    front: "Authentication Factors",
                    back:
                    "Definition: Common factors include knowledge (passwords, PINs), possession (security tokens, smartphones), inherence (biometrics), along with context (location, time).<br><br>Mitigation: Combine multiple factors and avoid overreliance on a single form of authentication."
                },
                {
                    front: "OAuth 2.0",
                    back:
                    "Definition: OAuth 2.0 is an authorization framework that lets third-party applications access user data without sharing user credentials.<br><br>Mitigation: Implement strict redirection and state validation, secure token management, and follow recommended best practices for OAuth deployments."
                },
                {
                    front: "OpenID Connect",
                    back:
                    "Definition: OpenID Connect is an authentication layer built on top of OAuth 2.0, allowing the verification of user identity along with authorization.<br><br>Mitigation: Validate identity tokens, enforce secure communication, and follow security guidelines for both OAuth and OpenID Connect."
                },
                {
                    front: "OAuth Grant Types",
                    back:
                    "Definition: OAuth 2.0 offers several grant types (e.g., Authorization Code, Implicit, Client Credentials, Resource Owner Password) to suit different use cases.<br><br>Mitigation: Choose the grant type appropriate for your threat model and implement additional measures such as PKCE for public clients."
                },
                {
                    front: "SAML",
                    back:
                    "Definition: SAML (Security Assertion Markup Language) is an XML-based standard for exchanging authentication and authorization data, commonly used in enterprise SSO.<br><br>Mitigation: Secure SAML messages with digital signatures, validate assertions, and ensure secure certificate management."
                },
                {
                    front: "Single Sign-On (SSO)",
                    back:
                    "Definition: SSO allows users to log in once and access multiple systems without re-entering credentials repeatedly.<br><br>Mitigation: Secure SSO implementations by using MFA, monitoring session activity, and ensuring strong central authentication mechanisms."
                },
                {
                    front: "Session-based Authentication",
                    back:
                    "Definition: Session-based authentication relies on a server-maintained session (often via cookies) to manage user logins.<br><br>Mitigation: Use secure, HttpOnly cookies, regenerate session IDs after login, set appropriate timeouts, and invalidate sessions on logout."
                },
                {
                    front: "Token-based Authentication",
                    back:
                    "Definition: Token-based authentication uses digitally signed tokens (often JWTs) that encode user identity and claims for stateless authentication.<br><br>Mitigation: Securely store tokens on the client, use HTTPS to transmit them, validate signatures on the server, and enforce token expiration."
                },
                {
                    front: "JWT (JSON Web Tokens)",
                    back:
                    "Definition: JWTs are self-contained tokens that carry user claims and are digitally signed to ensure authenticity.<br><br>Mitigation: Validate JWT signatures rigorously, enforce token expiry, use strong signing keys, and avoid including sensitive data in the payload."
                },
                {
                    front: "Role-Based Access Control (RBAC)",
                    back:
                    "Definition: RBAC assigns permissions to roles, and users are granted roles rather than individual privileges, simplifying access control.<br><br>Mitigation: Clearly define roles, adhere to the principle of least privilege, and regularly audit role assignments."
                },
                {
                    front: "Attribute-Based Access Control (ABAC)",
                    back:
                    "Definition: ABAC makes dynamic access decisions based on attributes (user, resource, action, environment), providing fine-grained control.<br><br>Mitigation: Develop robust policies that evaluate multiple attributes, test access decisions rigorously, and update policies as required."
                },
                {
                    front: "Passwordless Authentication",
                    back:
                    "Definition: Passwordless authentication verifies user identity through means other than passwords (e.g., biometrics, hardware tokens), reducing risks associated with password reuse.<br><br>Mitigation: Implement using secure standards (e.g., WebAuthn/FIDO2), combine with additional security checks, and ensure secure device management."
                },
                {
                    front: "WebAuthn / FIDO2",
                    back:
                    "Definition: WebAuthn (part of FIDO2) is a set of standards for passwordless authentication using public-key cryptography, offering strong resistance against phishing.<br><br>Mitigation: Implement using trusted hardware or platform authenticators, validate origin-bound credentials, and update integration as standards evolve."
                },
                {
                    front: "Secure Session Management",
                    back:
                    "Definition: Secure session management involves generating, validating, and expiring session tokens in a manner that protects against session hijacking and fixation.<br><br>Mitigation: Use secure cookies, enforce short session timeouts, regenerate session IDs after privilege changes, and store session data on the server securely."
                },
                {
                    front: "Cross-Site Request Forgery (CSRF) in Authentication",
                    back:
                    "Definition: CSRF targets authenticated sessions by tricking a user into making unintended requests.<br><br>Mitigation: Use anti-CSRF tokens, enforce SameSite cookie policies, and validate the Origin and Referer headers."
                },
                {
                    front: "Least Privilege",
                    back:
                    "Definition: The least privilege principle stipulates that processes and users receive only the access necessary for their tasks.<br><br>Mitigation: Regularly review permissions, enforce role-based or attribute-based access controls, and limit administrative access in day-to-day operations."
                },
                {
                    front: "Secure Password Policies",
                    back:
                    "Definition: Secure password policies favor longer, unique passwords without overly complex composition rules, reducing reuse and vulnerability to dictionary attacks.<br><br>Mitigation: Enforce minimum length requirements, check against known <br><br>eached passwords, and encourage use of password managers."
                },
                {
                    front: "CAPTCHA",
                    back:
                    "Definition: CAPTCHA distinguishes human users from automated scripts, protecting against <br><br>ute force and credential stuffing attacks.<br><br>Mitigation: Deploy CAPTCHA on login and form submissions sensitive to automation, balancing usability with security."
                },
                {
                    front: "Credential Stuffing",
                    back:
                    "Definition: Credential stuffing occurs when attackers use leaked username/password pairs from one <br><br>each to gain unauthorized access to other systems.<br><br>Mitigation: Enforce MFA, implement rate limiting and account lockout mechanisms, and monitor for abnormal login patterns."
                },
                {
                    front: "Account Enumeration",
                    back:
                    "Definition: Account enumeration allows attackers to determine valid accounts based on differences in responses for valid versus invalid usernames.<br><br>Mitigation: Return generic error messages for login failures, standardize response times, and implement rate limiting on login attempts."
                }
                ],
                mobile: [
                {
                    front: "Native vs. Hybrid vs. Web Mobile Applications",
                    back:
                    "Definition: Native applications are built for a specific platform using platform-specific languages (e.g., Swift for iOS), hybrid apps use web technologies within a native container, and web apps run in a <br><br>owser.<br><br>Mitigation: Apply security best practices for each type; for hybrid and web apps, pay extra attention to securing web-based components."
                },
                {
                    front: "Common Mobile Security Risks",
                    back:
                    "Definition: Mobile apps face risks such as insecure data storage, insecure communication, weak authentication, client-side injection, and excessive permissions.<br><br>Mitigation: Use platform-specific secure storage (Keychain/Keystore), enforce HTTPS, validate all inputs, and follow the principle of least privilege."
                },
                {
                    front: "OWASP Mobile Top 10",
                    back:
                    "Definition: The OWASP Mobile Top 10 lists the most critical mobile security risks, including insecure data storage, improper platform usage, and reverse engineering.<br><br>Mitigation: Regularly test mobile applications, apply security patches, and follow vendor-specific security guidelines."
                },
                {
                    front: "Android-specific Security Risks",
                    back:
                    "Definition: Android apps may suffer from vulnerabilities like insecure inter-component communication (Intents), permission mismanagement, and insecure WebViews.<br><br>Mitigation: Use runtime permissions, secure sensitive components, validate intents, and keep the platform up-to-date."
                },
                {
                    front: "iOS-specific Security Risks",
                    back:
                    "Definition: iOS apps can be vulnerable to issues such as insecure data storage in Keychain or plist files, improper certificate validation, and WebView vulnerabilities.<br><br>Mitigation: Leverage iOS security features (e.g., ATS, Keychain), validate certificates rigorously, and use secure coding practices."
                },
                {
                    front: "App Transport Security (ATS)",
                    back:
                    "Definition: ATS is an iOS feature that enforces the use of secure connections (HTTPS) between an app and backend services.<br><br>Mitigation: Configure ATS in the Info.plist to require HTTPS and only allow strong TLS configurations."
                },
                {
                    front: "App Signing",
                    back:
                    "Definition: App signing uses digital certificates to verify the authenticity and integrity of an app, ensuring it hasn’t been tampered with after distribution.<br><br>Mitigation: Use robust code-signing processes, protect private keys, and update certificates regularly."
                },
                {
                    front: "Certificate Pinning in Mobile Apps",
                    back:
                    "Definition: Certificate pinning restricts an app to only trust specific certificates, mitigating the risk of man-in-the-middle attacks even if a CA is compromised.<br><br>Mitigation: Embed trusted certificate fingerprints in the app, and update them as needed during re-signing or updates."
                },
                {
                    front: "Jail<br><br>eaking/Rooting",
                    back:
                    "Definition: Jail<br><br>eaking (iOS) or rooting (Android) bypasses device security mechanisms, exposing the device to additional malware and vulnerabilities.<br><br>Mitigation: Detect jail<br><br>oken/rooted devices and restrict app functionality accordingly, and educate users on the risks."
                },
                {
                    front: "Secure Local Data Storage",
                    back:
                    "Definition: Secure local data storage involves protecting sensitive data stored on the device (e.g., using secure system APIs like Keychain for iOS or Keystore for Android).<br><br>Mitigation: Encrypt sensitive data, use platform-specific secure storage solutions, and minimize data retention on the device."
                },
                {
                    front: "Biometric Authentication",
                    back:
                    "Definition: Biometric authentication uses unique biological traits (e.g., fingerprints, facial recognition) to verify identity in mobile applications.<br><br>Mitigation: Integrate with platform-native biometric APIs, combine with other authentication factors, and ensure secure transmission of authentication data."
                },
                {
                    front: "App Hardening / Anti-Tampering",
                    back:
                    "Definition: App hardening employs techniques such as code obfuscation, integrity checks, and anti-debugging to resist reverse engineering and tampering.<br><br>Mitigation: Use proven obfuscation methods, implement runtime integrity checks, and monitor for debug or tampering attempts."
                },
                {
                    front: "Handling Authentication Tokens in Mobile Apps",
                    back:
                    "Definition: Secure token handling involves safely storing and managing authentication tokens to prevent unauthorized reuse or theft.<br><br>Mitigation: Store tokens in platform-protected storage, enforce token expiration, use HTTPS for transmission, and invalidate tokens upon logout."
                },
                {
                    front: "Insecure Data Serialization in Mobile Apps",
                    back:
                    "Definition: Insecure serialization occurs when apps deserialize data without proper validation, which can lead to code execution or data tampering.<br><br>Mitigation: Validate serialized input rigorously, use safe serialization li<br><br>aries, and apply integrity checks on deserialized data."
                },
                {
                    front: "Deeplinks and Their Security Concerns",
                    back:
                    "Definition: Deeplinks allow direct linking to specific content within an app, but insecure implementation may expose sensitive parameters or enable phishing.<br><br>Mitigation: Validate deeplink inputs, enforce authentication for sensitive content, and sanitize parameters."
                },
                {
                    front: "WebView Security",
                    back:
                    "Definition: WebViews enable apps to render web content but can introduce risks like JavaScript injection and insecure content loading if improperly configured.<br><br>Mitigation: Restrict JavaScript execution to trusted sources, disable unnecessary features (e.g., file access), and enforce HTTPS for loaded content."
                },
                {
                    front: "Secure Communication in Mobile Apps",
                    back:
                    "Definition: Secure communication ensures that all data transmitted from a mobile app is encrypted and safeguarded against interception.<br><br>Mitigation: Enforce HTTPS, use certificate pinning, validate server certificates, and encrypt sensitive data in transit."
                },
                {
                    front: "Protecting Sensitive Data in Memory",
                    back:
                    "Definition: Protecting data in memory involves minimizing the time sensitive information is stored in an accessible state during app runtime.<br><br>Mitigation: Clear sensitive data as soon as it is no longer needed, use secure memory handling techniques, and avoid logging sensitive information."
                },
                {
                    front: "Secure Offline Authentication",
                    back:
                    "Definition: Offline authentication allows user verification without a network connection, but must be implemented securely to prevent unauthorized access.<br><br>Mitigation: Encrypt any cached credentials, enforce strict local timeouts, and require periodic re-authentication when online."
                },
                {
                    front: "Reverse Engineering in Mobile Apps",
                    back:
                    "Definition: Reverse engineering involves analyzing and decompiling app code to uncover vulnerabilities or proprietary logic.<br><br>Mitigation: Use code obfuscation, anti-debugging techniques, and enforce strong code signing to deter reverse engineering."
                },
                {
                    front: "Android Keystore System",
                    back:
                    "Definition: The Android Keystore provides a container for securely storing cryptographic keys such that they cannot be easily extracted from the device.<br><br>Mitigation: Use the Keystore for storing keys, implement proper access controls, and update security practices as the platform evolves."
                },
                {
                    front: "iOS Keychain",
                    back:
                    "Definition: The iOS Keychain is a secure storage system for sensitive data like passwords and cryptographic keys.<br><br>Mitigation: Use Keychain APIs properly, enforce access control levels, and ensure sensitive data isn’t exposed in backups or logs."
                }
                ],
                "ssl-tls": [
                {
                    front: "SSL vs. TLS",
                    back:
                    "Definition: TLS is the modern, more secure replacement for SSL; all SSL versions are now deprecated due to known vulnerabilities.<br><br>Mitigation: Disable all SSL protocols and configure servers to use TLS 1.2 or TLS 1.3 exclusively with strong cipher suites."
                },
                {
                    front: "TLS Handshake",
                    back:
                    "Definition: The TLS handshake negotiates the encryption parameters between client and server, establishing a secure channel.<br><br>Mitigation: Ensure that handshake protocols are up-to-date, disable insecure legacy protocol versions, and patch all security flaws promptly."
                },
                {
                    front: "Cipher Suites",
                    back:
                    "Definition: Cipher suites are sets of algorithms used for key exchange, bulk encryption, and message authentication in TLS.<br><br>Mitigation: Allow only strong cipher suites with perfect forward secrecy and disable legacy algorithms."
                },
                {
                    front: "Insecure Ciphers",
                    back:
                    "Definition: Insecure ciphers (e.g., RC4, DES/3DES, export-grade ciphers) weaken TLS encryption and are vulnerable to attacks.<br><br>Mitigation: Remove weak ciphers from server configurations and only allow modern, recommended ciphers."
                },
                {
                    front: "Perfect Forward Secrecy (PFS)",
                    back:
                    "Definition: PFS ensures that a compromise of long-term keys does not affect past encrypted sessions by using unique ephemeral keys for each connection.<br><br>Mitigation: Enable ephemeral key exchanges (DHE or ECDHE) in TLS configurations."
                },
                {
                    front: "TLS 1.2 vs. TLS 1.3",
                    back:
                    "Definition: TLS 1.3 improves security and efficiency by reducing handshake latency and removing outdated cryptographic algorithms compared to TLS 1.2.<br><br>Mitigation: Upgrade to TLS 1.3 where supported, and disable older protocols to minimize exposure."
                },
                {
                    front: "Certificate Transparency (CT)",
                    back:
                    "Definition: CT is a system of logging and monitoring SSL/TLS certificates to detect and deter misissued certificates.<br><br>Mitigation: Monitor CT logs for unauthorized certificates and use certificate pinning for critical applications."
                },
                {
                    front: "OCSP and OCSP Stapling",
                    back:
                    "Definition: OCSP checks the revocation status of certificates in real time, while OCSP stapling allows servers to send this information during the TLS handshake.<br><br>Mitigation: Enable OCSP stapling on servers to improve performance and ensure timely revocation checks."
                },
                {
                    front: "SNI (Server Name Indication)",
                    back:
                    "Definition: SNI allows a client to indicate the hostname it is trying to reach during the TLS handshake, enabling one server to host multiple domains securely.<br><br>Mitigation: Ensure that SNI configurations match certificates correctly and that multi-tenant environments are properly isolated."
                },
                {
                    front: "Common SSL/TLS Vulnerabilities",
                    back:
                    "Definition: Vulnerabilities such as BEAST, POODLE, Heartbleed, CRIME, and Logjam exploit weaknesses in older TLS/SSL protocols and configurations.<br><br>Mitigation: Patch vulnerable software, disable legacy protocols and ciphers, and continuously monitor and update TLS configurations."
                },
                {
                    front: "Heartbleed",
                    back:
                    "Definition: Heartbleed (CVE-2014-0160) was a critical vulnerability in OpenSSL that allowed attackers to read private memory from affected servers.<br><br>Mitigation: Immediately update OpenSSL to a patched version, rotate exposed keys and certificates, and audit systems for signs of exploitation."
                },
                {
                    front: "Certificate Pinning",
                    back:
                    "Definition: Certificate pinning hardcodes the expected certificate or public key in an application, preventing MitM attacks even if a CA is compromised.<br><br>Mitigation: Implement pinning in critical applications and update pins in a controlled manner when certificates change."
                },
                {
                    front: "HTTP Strict Transport Security (HSTS)",
                    back:
                    "Definition: HSTS is a security policy that instructs <br><br>owsers to only connect via HTTPS, protecting against protocol downgrade attacks.<br><br>Mitigation: Enable HSTS on the web server with an adequate max-age, include subdomains if needed, and ensure that all resources are available over HTTPS."
                },
                {
                    front: "Self-signed vs. CA-signed Certificates",
                    back:
                    "Definition: Self-signed certificates are generated and signed by the owner, while CA-signed certificates are verified by trusted authorities, resulting in trusted authentication in <br><br>owsers.<br><br>Mitigation: Use CA-signed certificates in production for proper trust and only use self-signed certificates for testing or internal purposes."
                },
                {
                    front: "Wildcard Certificates",
                    back:
                    "Definition: Wildcard certificates secure an entire domain and its first-level subdomains with a single certificate.<br><br>Mitigation: Protect wildcard certificate private keys rigorously and consider the impact of a potential compromise on multiple subdomains."
                },
                {
                    front: "X.509 Certificate Components",
                    back:
                    "Definition: X.509 certificates contain key information such as version, serial number, issuer, validity period, subject, public key info, and extensions.<br><br>Mitigation: Validate all certificate components, enforce proper expiration and revocation policies, and secure the chain of trust."
                },
                {
                    front: "SSL/TLS Inspection Proxies",
                    back:
                    "Definition: SSL/TLS inspection proxies decrypt and inspect encrypted traffic to detect threats but may undermine end-to-end encryption.<br><br>Mitigation: Configure inspection proxies securely, limit the scope of inspection to necessary traffic, and ensure that they do not expose sensitive data."
                },
                {
                    front: "TLS Downgrade Attacks",
                    back:
                    "Definition: TLS downgrade attacks force a connection to revert to an older, less secure protocol version during handshake negotiation.<br><br>Mitigation: Disable legacy protocols and ciphers, implement TLS_FALLBACK_SCSV, and configure servers to refuse downgrades."
                },
                {
                    front: "Extended Validation (EV) Certificates",
                    back:
                    "Definition: EV certificates involve a rigorous identity verification process by the issuing CA, resulting in higher trust levels and distinct <br><br>owser indicators.<br><br>Mitigation: Use EV certificates where strong identity assurance is required, and maintain strict validation processes during the issuance."
                },
                {
                    front: "Secure TLS Server Configuration",
                    back:
                    "Definition: A secure TLS configuration minimizes vulnerability exposure by using updated protocols, strong ciphers, and proper certificate chains.<br><br>Mitigation: Regularly audit TLS settings, follow established best practices and guidelines, and patch server software promptly."
                },
                {
                    front: "Diffie-Hellman Key Exchange",
                    back:
                    "Definition: Diffie-Hellman key exchange allows two parties to generate a shared secret over an insecure channel without exchanging the secret directly.<br><br>Mitigation: Use ephemeral Diffie-Hellman (DHE/ECDHE) with strong parameters to ensure Perfect Forward Secrecy."
                },
                {
                    front: "TLS 1.3 0-RTT Feature",
                    back:
                    "Definition: The 0-RTT feature in TLS 1.3 allows data to be sent during the initial handshake to reduce latency, though it carries replay attack risks.<br><br>Mitigation: Restrict 0-RTT to idempotent requests and implement robust server-side replay protection mechanisms."
                },
                {
                    front: "Certificate Revocation Lists (CRLs)",
                    back:
                    "Definition: CRLs are lists of revoked certificates published by CAs, used to check the revocation status of a certificate.<br><br>Mitigation: Consider using OCSP and OCSP stapling for more timely revocation status, and monitor CRLs as part of an overall certificate management strategy."
                },
                {
                    front: "SSL/TLS Session Resumption",
                    back:
                    "Definition: Session resumption enables reusing session parameters for faster reconnections without a full handshake.<br><br>Mitigation: Use secure methods (session tickets, PSK in TLS 1.3) and ensure stored session data is protected against unauthorized reuse."
                }
                ],
                pentesting: [
                {
                    front: "Penetration Testing",
                    back:
                    "Definition: Penetration testing is a simulated real-world attack against a system designed to uncover and exploit vulnerabilities.<br><br>Mitigation: Use test results to harden systems, remediate identified vulnerabilities, and update defensive measures accordingly."
                },
                {
                    front: "Pentest Phases",
                    back:
                    "Definition: Penetration tests typically follow these phases: Planning & Reconnaissance, Scanning, Exploitation (Gaining Access), Post-Exploitation (Maintaining Access & Lateral Movement), and Reporting.<br><br>Mitigation: Follow a structured methodology to ensure thorough assessments while minimizing the risk of unintended disruption."
                },
                {
                    front: "Black Box vs. White Box vs. Gray Box Testing",
                    back:
                    "Definition: Black box testing simulates an external attacker with no prior knowledge; white box testing uses full internal information; gray box testing provides limited internal insight.<br><br>Mitigation: Select the appropriate testing model based on risk, scope, and objectives to maximize realistic threat simulation."
                },
                {
                    front: "Active vs. Passive Reconnaissance",
                    back:
                    "Definition: Active reconnaissance involves directly interacting with the target (e.g., port scans), while passive reconnaissance uses publicly available information (e.g., OSINT) without detection.<br><br>Mitigation: Use reconnaissance techniques with caution to avoid unwanted detection and remain within legal and ethical boundaries."
                },
                {
                    front: "OSINT in Penetration Testing",
                    back:
                    "Definition: OSINT (Open Source Intelligence) gathers publicly available information to identify potential vulnerabilities and plan subsequent tests.<br><br>Mitigation: Combine OSINT with other methodologies, and use gathered information to fortify defenses rather than solely for exploitation."
                },
                {
                    front: "Least Privilege in Pentesting",
                    back:
                    "Definition: Even during testing, using accounts with minimal privileges reflects real-world conditions and reduces the risk of unintended harm.<br><br>Mitigation: Configure test accounts with only the permissions necessary to perform specific tasks."
                },
                {
                    front: "Port Scanning Techniques",
                    back:
                    "Definition: Common techniques include TCP SYN scans (stealthy), TCP connect scans (more reliable but detectable), UDP scans, FIN/XMAS/NULL scans (to evade firewalls), and more.<br><br>Mitigation: Understand scanning methods to identify suspicious behavior on your networks and deploy intrusion detection systems to flag abnormal scans."
                },
                {
                    front: "Vulnerability Scanning vs. Penetration Testing",
                    back:
                    "Definition: Vulnerability scanning uses automated tools to identify known weaknesses, while penetration testing actively exploits vulnerabilities to assess real-world risk.<br><br>Mitigation: Use both approaches together to complement each other, ensuring <br><br>oad coverage and realistic impact assessment."
                },
                {
                    front: "Common Web Application Pentesting Tools",
                    back:
                    "Definition: Tools such as Burp Suite, OWASP ZAP, SQLmap, Nikto, Metasploit, Dirb/Gobuster, and BeEF assist testers in finding and exploiting web vulnerabilities.<br><br>Mitigation: Use these tools to identify flaws and follow up with targeted remediation measures and secure coding practices."
                },
                {
                    front: "Credential Stuffing Testing",
                    back:
                    "Definition: Credential stuffing tests simulate the use of leaked credentials to determine if an application is vulnerable to automated login attacks.<br><br>Mitigation: Enforce rate limiting, account lockouts, and multi-factor authentication to mitigate credential reuse risks."
                },
                {
                    front: "Privilege Escalation",
                    back:
                    "Definition: Privilege escalation involves gaining higher access levels than originally granted, often by exploiting misconfigurations or software vulnerabilities.<br><br>Mitigation: Patch vulnerabilities, enforce least privilege policies, and monitor systems for unusual privilege changes."
                },
                {
                    front: "Lateral Movement",
                    back:
                    "Definition: Lateral movement is the process of moving through a network after an initial compromise to access additional resources.<br><br>Mitigation: Segment networks, enforce strict access controls between systems, and monitor internal traffic for anomalous behavior."
                },
                {
                    front: "Pivoting",
                    back:
                    "Definition: Pivoting uses a compromised system as a launching pad to attack otherwise unreachable segments of a network.<br><br>Mitigation: Limit access between network segments, use firewalls, and monitor for unexpected inter-network traffic."
                },
                {
                    front: "Session Hijacking",
                    back:
                    "Definition: Session hijacking is the theft or misuse of a valid session token to impersonate a user and gain unauthorized access.<br><br>Mitigation: Use secure cookies (HttpOnly, Secure), regenerate session IDs after authentication, enforce proper timeouts, and tie sessions to additional parameters (IP address, user agent)."
                },
                {
                    front: "Directory Traversal Testing",
                    back:
                    "Definition: Directory traversal attacks attempt to access files outside the we<br><br>oot by exploiting file path manipulation.<br><br>Mitigation: Sanitize and validate file path inputs, normalize paths, and enforce strict file system permissions."
                },
                {
                    front: "Race Condition Testing",
                    back:
                    "Definition: Race condition tests focus on identifying timing vulnerabilities where the order or speed of operations can be exploited.<br><br>Mitigation: Use proper synchronization and atomic operations, and test concurrent processes under varied conditions."
                },
                {
                    front: "Exploit Chaining",
                    back:
                    "Definition: Exploit chaining combines multiple vulnerabilities in a sequence to escalate an attack beyond what one flaw would allow.<br><br>Mitigation: Remediate vulnerabilities holistically rather than in isolation and conduct comprehensive system hardening and segmentation."
                },
                {
                    front: "Vulnerability Verification vs. Exploitation",
                    back:
                    "Definition: Verification confirms the existence of a vulnerability (often non-destructively) while exploitation involves actively leveraging it for unauthorized access or control.<br><br>Mitigation: Use verification techniques during testing to prioritize remediation without causing disruption in production systems."
                },
                {
                    front: "Evasion Techniques",
                    back:
                    "Definition: Evasion techniques include methods (like packet fragmentation, payload obfuscation, or using nonstandard ports) designed to bypass detection mechanisms such as IDS/IPS.<br><br>Mitigation: Deploy multi-layered detection systems, use anomaly-based monitoring, and update defensive signatures frequently."
                },
                {
                    front: "Post-Exploitation",
                    back:
                    "Definition: Post-exploitation involves actions after gaining access, such as data exfiltration, lateral movement, and persistence testing, to assess the full impact of a <br><br>each.<br><br>Mitigation: Harden systems to prevent further exploitation, segment networks, and monitor for advanced threat behaviors to detect any post-compromise activity."
                },
                {
                    front: "WAF Bypass Techniques",
                    back:
                    "Definition: WAF bypass techniques try to evade web application firewalls through obfuscation, alternative encodings, or parameter manipulation.<br><br>Mitigation: Regularly update and fine-tune WAF rules, use deep packet inspection, and combine multiple layers of defense to catch obfuscated payloads."
                },
                {
                    front: "Active Directory Enumeration",
                    back:
                    "Definition: Active Directory enumeration gathers information on domain structure, users, groups, and policies, which can later be used in targeted attacks.<br><br>Mitigation: Secure AD configurations, enforce strong passwords and account lockouts, and monitor directory queries for suspicious activity."
                },
                {
                    front: "Pentest Report Essentials",
                    back:
                    "Definition: A comprehensive pentest report includes an executive summary, a detailed technical explanation of findings (with evidence), risk and impact assessments, and actionable remediation recommendations.<br><br>Mitigation: Ensure reports are clear, unambiguous, and tailored to both technical and non-technical stakeholders."
                },
                {
                    front: "Ethical Considerations",
                    back:
                    "Definition: Ethical pentesting requires proper authorization, adherence to scope boundaries, transparency with stakeholders, and safeguarding data during tests.<br><br>Mitigation: Always obtain written permission, document all actions, and follow industry ethical standards and guidelines."
                },
                {
                    front: "Red Team Assessment",
                    back:
                    "Definition: A Red Team assessment simulates a full-scale, multi-vector attack (including physical, social, and digital) over an extended period to test an organization’s overall security posture.<br><br>Mitigation: Use red teaming to identify weaknesses across defenses and integrate findings into an organization-wide security improvement program."
                },
                // New pentesting items for OS-specific attacks:
                {
                    front: "Windows Privilege Escalation",
                    back:
                    "Definition: Windows Privilege Escalation involves exploiting vulnerabilities or misconfigurations in Windows environments to gain administrative privileges from a lower-level account.<br><br>Mitigation: Regularly patch systems, limit local administrator rights, configure User Account Control (UAC) properly, and monitor for unusual privilege changes."
                },
                {
                    front: "Linux Privilege Escalation",
                    back:
                    "Definition: Linux Privilege Escalation exploits misconfigurations, kernel vulnerabilities, or software bugs to gain root access from a standard user account.<br><br>Mitigation: Keep the OS and all packages updated, restrict sudo privileges, audit file permissions, and use security tools to identify misconfigurations."
                },
                {
                    front: "macOS Privilege Escalation",
                    back:
                    "Definition: macOS Privilege Escalation involves attacking inherent vulnerabilities or misconfigurations in macOS to obtain elevated privileges.<br><br>Mitigation: Apply regular security updates, use built-in protections like System Integrity Protection (SIP), restrict administrative access, and monitor system logs for anomalous behavior."
                }
            ]
        };
// this is the end of the questions

        // Initialize variables
        let currentCategory = 'owasp';
        let currentCardIndex = 0;
        let isFlipped = false;

        // DOM elements
        const flashcardEl = document.getElementById('flashcard');
        const frontContentEl = document.getElementById('front-content');
        const backContentEl = document.getElementById('back-content');
        const categorySelectEl = document.getElementById('category-select');
        const prevButtonEl = document.getElementById('prev-button');
        const nextButtonEl = document.getElementById('next-button');
        const counterEl = document.getElementById('counter');

        // Function to display the current card
        function displayCard() {
            const cards = flashcards[currentCategory];
            const currentCard = cards[currentCardIndex];
            
            frontContentEl.textContent = currentCard.front;
            backContentEl.innerHTML = currentCard.back;
            counterEl.textContent = `Card ${currentCardIndex + 1} of ${cards.length}`;
            
            // Reset flip state
            isFlipped = false;
            flashcardEl.classList.remove('flipped');
        }

        // Function to handle category change
        function handleCategoryChange() {
            currentCategory = categorySelectEl.value;
            currentCardIndex = 0;
            displayCard();
        }

        // Function to handle card flipping
        function handleCardFlip() {
            isFlipped = !isFlipped;
            if (isFlipped) {
                flashcardEl.classList.add('flipped');
            } else {
                flashcardEl.classList.remove('flipped');
            }
        }

        // Function to go to the previous card
        function goToPrevCard() {
            const cards = flashcards[currentCategory];
            currentCardIndex = (currentCardIndex - 1 + cards.length) % cards.length;
            displayCard();
        }

        // Function to go to the next card
        function goToNextCard() {
            const cards = flashcards[currentCategory];
            currentCardIndex = (currentCardIndex + 1) % cards.length;
            displayCard();
        }

        // Event listeners
        categorySelectEl.addEventListener('change', handleCategoryChange);
        flashcardEl.addEventListener('click', handleCardFlip);
        prevButtonEl.addEventListener('click', goToPrevCard);
        nextButtonEl.addEventListener('click', goToNextCard);

        // Swipe functionality
        let touchStartX = 0;
        let touchEndX = 0;
        
        function handleTouchStart(e) {
            touchStartX = e.changedTouches[0].screenX;
        }
        
        function handleTouchEnd(e) {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }
        
        function handleSwipe() {
            if (touchEndX < touchStartX - 50) {
                // Swipe left
                goToNextCard();
            } else if (touchEndX > touchStartX + 50) {
                // Swipe right
                goToPrevCard();
            }
        }
        
        document.addEventListener('touchstart', handleTouchStart, false);
        document.addEventListener('touchend', handleTouchEnd, false);

        // Initialize the app
        displayCard();
    </script>
</body>
</html>
